datos = as.data.frame(t(tabla))
metodo = rep(c(names(datos)),each = p)
N = rep(n,3 )
####
resultados = data.frame(valores = c(datos[,1],datos[,2],datos[,3]),
metodo,N)
resultados
library(ggplot2)
A = ggplot(resultados,aes( x = N,
y = valores,
group = metodo,
col = metodo))+
geom_line(lwd = 2) +
geom_point(size = 3, col = "black") +
theme_bw() +
theme(legend.position = "bottom")
A
A = ggplot(resultados,aes( x = N,
y = valores,
group = metodo,
col = metodo))+
geom_line(lwd = 1) +
geom_point(size = 3, col = "black") +
theme_bw() +
theme(legend.position = "bottom")
A
library(plotly)
A = ggplot(resultados,aes( x = N,
y = valores,
group = metodo,
col = metodo))+
geom_line(lwd = 0.5) +
geom_point(size = 3, col = "black") +
theme_bw() +
theme(legend.position = "bottom")
A
A = ggplot(resultados,aes( x = N,
y = valores,
group = metodo,
col = metodo))+
geom_line(lwd = 1) +
geom_point(size = 3, col = "black") +
theme_bw() +
theme(legend.position = "bottom")
A
p = 4
n = (1:p)*5
tabla = data.frame(Mitad = 0, Fibonacci = 0, Dorada = 0)
for(i in 1:length(n)){
tabla[i,] = c(Mitad = ((0.5)^(n[i] /2)),
Fibonacci = (2/(FIBO(n[i]))), Dorada = (0.618^(n[i]-1)) )
}
tabla = as.data.frame(round(t(tabla),6))
names(tabla) = n
library(flextable)
theme_box(flextable(tabla))
datos = as.data.frame(t(tabla))
metodo = rep(c(names(datos)),each = p)
N = rep(n,3 )
####
resultados = data.frame(valores = c(datos[,1],datos[,2],datos[,3]),
metodo,N)
resultados
library(ggplot2)
A = ggplot(resultados,aes( x = N,
y = valores,
group = metodo,
col = metodo))+
geom_line(lwd = 1) +
geom_point(size = 3, col = "black") +
theme_bw() +
theme(legend.position = "bottom")
A
ggplotly(A)
ggplotly(A)
tabla
A
A = ggplot(resultados,aes( x = N,
y = log(valores),
group = metodo,
col = metodo))+
geom_line(lwd = 1) +
geom_point(size = 3, col = "black") +
theme_bw() +
theme(legend.position = "bottom");A
p = 10
n = (1:p)*5
A
tabla = data.frame(Mitad = 0, Fibonacci = 0, Dorada = 0)
for(i in 1:length(n)){
tabla[i,] = c(Mitad = ((0.5)^(n[i] /2)),
Fibonacci = (2/(FIBO(n[i]))), Dorada = (0.618^(n[i]-1)) )
}
tabla = as.data.frame(round(t(tabla),6))
names(tabla) = n
library(flextable)
theme_box(flextable(tabla))
datos = as.data.frame(t(tabla))
metodo = rep(c(names(datos)),each = p)
N = rep(n,3 )
####
resultados = data.frame(valores = c(datos[,1],datos[,2],datos[,3]),
metodo,N)
resultados
library(ggplot2)
A = ggplot(resultados,aes( x = N,
y = log(valores),
group = metodo,
col = metodo))+
geom_line(lwd = 1) +
geom_point(size = 3, col = "black") +
theme_bw() +
theme(legend.position = "bottom");A
A = ggplot(resultados,aes( x = N,
y = log(valores),
group = metodo,
col = metodo))+
geom_line(lwd = 1) +
geom_point(size = 3, col = "black") +
theme_bw() +
theme(legend.position = "bottom");A
A
FIBO(n+1)
p = 10
n = (1:p)*5
A
FIBO(n+1)
p = 10
n = (1:p)*5
A
tabla = data.frame(Mitad = 0, Fibonacci = 0, Dorada = 0)
tabla = data.frame(Mitad = 0, Fibonacci = 0, Dorada = 0)
for(i in 1:length(n)){
tabla[i,] = c(Mitad = ((0.5)^(n[i] /2)),
Fibonacci = (2/(FIBO(n[i]))), Dorada = (0.618^(n[i]-1)) )
}
tabla = as.data.frame(round(t(tabla),6))
names(tabla) = n
library(flextable)
theme_box(flextable(tabla))
datos = as.data.frame(t(tabla))
metodo = rep(c(names(datos)),each = p)
N = rep(n,3 )
####
resultados = data.frame(valores = c(datos[,1],datos[,2],datos[,3]),
metodo,N)
resultados
library(ggplot2)
A = ggplot(resultados,aes( x = N,
y = log(valores),
group = metodo,
col = metodo))+
geom_line(lwd = 1) +
geom_point(size = 3, col = "black") +
theme_bw() +
theme(legend.position = "bottom");A
A = ggplot(resultados,aes( x = N,
y = log(valores),
group = metodo,
col = metodo))+
geom_line(lwd = 1) +
geom_point(size = 3, col = "black") +
theme_bw() +
theme(legend.position = "bottom") +
coord_cartesian(ylim = c(0,-30)) ;A
A = ggplot(resultados,aes( x = N,
y = log(valores),
group = metodo,
col = metodo))+
geom_line(lwd = 1) +
geom_point(size = 3, col = "black") +
theme_bw() +
theme(legend.position = "bottom") +
coord_cartesian(ylim = c(30,-30)) ;A
A = ggplot(resultados,aes( x = N,
y = log(valores),
group = metodo,
col = metodo))+
geom_line(lwd = 1) +
geom_point(size = 3, col = "black") +
theme_bw() +
theme(legend.position = "bottom") +
coord_cartesian(ylim = c(50,-50)) ;A
A = ggplot(resultados,aes( x = N,
y = log(valores),
group = metodo,
col = metodo))+
geom_line(lwd = 1) +
geom_point(size = 3, col = "black") +
theme_bw() +
theme(legend.position = "bottom") +
coord_cartesian(ylim = c(-50,0)) ;A
A = ggplot(resultados,aes( x = N,
y = log(valores),
group = metodo,
col = metodo))+
geom_line(lwd = 1) +
geom_point(size = 3, col = "black") +
theme_bw() +
theme(legend.position = "bottom") +
coord_cartesian(ylim = c(-1000,0)) ;A
A = ggplot(resultados,aes( x = N,
y = log(valores),
group = metodo,
col = metodo))+
geom_line(lwd = 1) +
geom_point(size = 3, col = "black") +
theme_bw() +
theme(legend.position = "bottom") +
coord_cartesian(ylim = c(-20,0)) ;A
Dorado(fx,0,5,0.00000001)
# Actualizo el valor de Lw y de K
Lw = bw-aw
Dorado(fx,0,5,0.0000001)
Dorado(fx,0,5,0.00001)
Dorado(fx,0,5,0.000001)
A = ggplot(resultados,aes( x = N,
y = log(valores,2),
group = metodo,
col = metodo))+
geom_line(lwd = 1) +
geom_point(size = 3, col = "black") +
theme_bw() +
theme(legend.position = "bottom") +
coord_cartesian(ylim = c(-20,0)) ;A
rm(list=ls())
fx = function(x){x^2 + 54/x}
#### Paso 1 ####
a = 0
b = 5
Dorado = function(fx,a,b,epsilon){
# Transformar los datos a un intervalo de 0 y 1
tw = function(x){(x-a)/(b-a)}
# Transformador de W a X
tx = function(w){w*(b-a) + a }
# Calcular el a y b remapeados en w
aw = tw(a); bw = tw(b)
# Definir Lw
Lw = bw - aw
# Definir k
k = 1
#### Paso 3 implicito por ser iterativo hasta que se cumpla la cond de paro
while(epsilon<Lw){
#### Paso 2 ####
# Definir el w1 y el w2 como pasos intermedios
w1 = aw + (0.618)*Lw
w2 = bw - (0.618)*Lw
# Evaluar los f(w1) y f(w2)
fw1 = fx(tx(w1))
fw2 = fx(tx(w2))
# Evaluar que región eliminar
if(fw1 < fw2){
# Asignar el nuevo aw
aw = w2
}else{# EN caso de que fw1 sea mayor a fw2
bw = w1
}
# Actualizo el valor de Lw y de K
Lw = bw-aw
k = k+1
}
# Regresar el intervalo transformado
resultado = c(a = tx(aw),b = tx(bw),Iter = k)
return(resultado)
}
Dorado(fx,0,5,0.000001)
Dorado = function(fx,a,b,epsilon){
# Transformar los datos a un intervalo de 0 y 1
tw = function(x){(x-a)/(b-a)}
# Transformador de W a X
tx = function(w){w*(b-a) + a }
# Calcular el a y b remapeados en w
aw = tw(a); bw = tw(b)
# Definir Lw
Lw = bw - aw
# Definir k
k = 1
#### Paso 3 implicito por ser iterativo hasta que se cumpla la cond de paro
# Crear una estructura para guardar los resultados de las iteraciones
resultado = data.frame(a = a, b = b,Iter = k)
while(epsilon<Lw){
#### Paso 2 ####
# Definir el w1 y el w2 como pasos intermedios
w1 = aw + (0.618)*Lw
w2 = bw - (0.618)*Lw
# Evaluar los f(w1) y f(w2)
fw1 = fx(tx(w1))
fw2 = fx(tx(w2))
# Evaluar que región eliminar
if(fw1 < fw2){
# Asignar el nuevo aw
aw = w2
}else{# EN caso de que fw1 sea mayor a fw2
bw = w1
}
# Actualizo el valor de Lw y de K
Lw = bw-aw
k = k+1
# Agregar los valores
resultado[k,] = data.frame(a = tw(a) , b = tw(b),Iter = k)
}
# Regresar el intervalo transformado
return(resultado)
}
Dorado(fx,0,5,0.000001)
Dorado = function(fx,a,b,epsilon){
# Transformar los datos a un intervalo de 0 y 1
tw = function(x){(x-a)/(b-a)}
# Transformador de W a X
tx = function(w){w*(b-a) + a }
# Calcular el a y b remapeados en w
aw = tw(a); bw = tw(b)
# Definir Lw
Lw = bw - aw
# Definir k
k = 1
#### Paso 3 implicito por ser iterativo hasta que se cumpla la cond de paro
# Crear una estructura para guardar los resultados de las iteraciones
resultado = data.frame(a = a, b = b,Iter = k)
while(epsilon<Lw){
#### Paso 2 ####
# Definir el w1 y el w2 como pasos intermedios
w1 = aw + (0.618)*Lw
w2 = bw - (0.618)*Lw
# Evaluar los f(w1) y f(w2)
fw1 = fx(tx(w1))
fw2 = fx(tx(w2))
# Evaluar que región eliminar
if(fw1 < fw2){
# Asignar el nuevo aw
aw = w2
}else{# EN caso de que fw1 sea mayor a fw2
bw = w1
}
# Actualizo el valor de Lw y de K
Lw = bw-aw
k = k+1
# Agregar los valores
resultado[k,] = data.frame(a = tw(aw) , b = tw(bw),Iter = k)
}
# Regresar el intervalo transformado
return(resultado)
}
Dorado(fx,0,5,0.000001)
Dorado = function(fx,a,b,epsilon){
# Transformar los datos a un intervalo de 0 y 1
tw = function(x){(x-a)/(b-a)}
# Transformador de W a X
tx = function(w){w*(b-a) + a }
# Calcular el a y b remapeados en w
aw = tw(a); bw = tw(b)
# Definir Lw
Lw = bw - aw
# Definir k
k = 1
#### Paso 3 implicito por ser iterativo hasta que se cumpla la cond de paro
# Crear una estructura para guardar los resultados de las iteraciones
resultado = data.frame(a = a, b = b,Iter = k)
while(epsilon<Lw){
#### Paso 2 ####
# Definir el w1 y el w2 como pasos intermedios
w1 = aw + (0.618)*Lw
w2 = bw - (0.618)*Lw
# Evaluar los f(w1) y f(w2)
fw1 = fx(tx(w1))
fw2 = fx(tx(w2))
# Evaluar que región eliminar
if(fw1 < fw2){
# Asignar el nuevo aw
aw = w2
}else{# EN caso de que fw1 sea mayor a fw2
bw = w1
}
# Actualizo el valor de Lw y de K
Lw = bw-aw
k = k+1
# Agregar los valores
resultado[k,] = data.frame(a = tx(aw) , b = tx(bw),Iter = k)
}
# Regresar el intervalo transformado
return(resultado)
}
Dorado(fx,0,5,0.000001)
Dorado(fx,0,5,0.01)
Dorado(fx,0,5,0.01)
Dorado = function(fx,a,b,epsilon){
#### Paso 1 ####
# Transformar los datos a un intervalo de 0 y 1
tw = function(x){(x-a)/(b-a)}
# Transformador de W a X
tx = function(w){w*(b-a) + a }
# Calcular el a y b remapeados en w
aw = tw(a); bw = tw(b)
# Definir Lw
Lw = bw - aw
# Definir k
k = 1
#### Paso 3 implicito por ser iterativo hasta que se cumpla la cond de paro
# Crear una estructura para guardar los resultados de las iteraciones
resultado = data.frame(a = a, b = b,Iter = k)
while(epsilon<Lw){
#### Paso 2 ####
# Definir el w1 y el w2 como pasos intermedios
w1 = aw + (0.618)*Lw
w2 = bw - (0.618)*Lw
# Evaluar los f(w1) y f(w2)
fw1 = fx(tx(w1))
fw2 = fx(tx(w2))
# Evaluar que región eliminar
if(fw1 < fw2){
# Asignar el nuevo aw
aw = w2
}else{# EN caso de que fw1 sea mayor a fw2
bw = w1
}
# Actualizo el valor de Lw y de K
Lw = bw-aw
k = k+1
# Agregar los valores
resultado[k,] = data.frame(a = tx(aw) , b = tx(bw),Iter = k)
}
# Regresar el intervalo transformado
return(resultado)
}
rm(list=ls())
source("Tarea 4. Busqueda la sección dorada MAIN.R")
#### Evaluación para el ejercicio de clase ####
# a = 0
# b = 5
# epsilon = 0.01
res1 = round(Dorado(fx,0,5,0.01),6)
res1
res2 = round(Dorado(fx,0,5,0.001),6)
res2
#### Evaluación propuesta de hacer más pequeño el epsilon####
# a = 0
# b = 5
# epsilon = 0.001
res3 = round(Dorado(fx,0,5,0.0001),6)
res3
knitr::opts_chunk$set(echo = F,
eval = F,
message = F,
warning = F)
# Librería para hacer las tablas bonitas
library(flextable)
# Llamo el código
source("Tarea 4. Busqueda la sección dorada MAIN.R")
# Declaro la función que se desea minimizar
fx = function(x){(x^2) +  (54/x)}
#### Evaluación para el ejercicio de clase ####
# a = 0
# b = 5
# epsilon = 0.01
res1 = round(Dorado(fx,0,5,0.01),6)
res1
# Reportar los resultados bonitos
autofit(align(theme_box(flextable(res1)), align = "center", part = "all"))
# Reportar los resultados bonitos
autofit(align(theme_box(flextable(res1)), align = "center", part = "all"))
# Reportar los resultados bonitos
autofit(align(theme_box(flextable(res1)), align = "center", part = "all"))
#### Evaluación propuesta de hacer más pequeño el epsilon####
# a = 0
# b = 5
# epsilon = 0.001
res2 = round(Dorado(fx,0,5,0.001),6)
# Reportar los resultados bonitos
autofit(align(theme_box(flextable(res2)), align = "center", part = "all"))
#### Búsqueda Exhaustiva ####
# fx = Función de la cual se quiere saber el mínimo
# a =  limite inferior del intervalo
# b = limite superior del intervalo
# n = tolerancia permitida
rm(list = ls())
BE = function(fx,a,b,n){
#### Paso 1 ####
# Definir el punto x1 y el punto deltaX
x1 = a
Dx = (b-a)/n;Dx
# Definir el punto x2 y el punto x3
x2 = x1 + Dx
x3 = x2 + Dx
#### Paso 3 como condición de paro ####
# Creo un objeto para guardaar el resultado de las iteraciones #
contador = 0
resultados = data.frame(a = 0,b = 0, n = 0)
while(x3<=b){
#### Paso 2 ####
# Evaluar las funciones #
fx1 = fx(x1)
fx2 = fx(x2)
fx3 = fx(x3)
# Agregar los valores de x1 y x3
contador = contador + 1
resultados[contador,] = c(x1,x3,contador)
# Verificar si se cumple la condición
if(fx1 >= fx2 & fx2<=fx3){
# EL minimo se encuentra en (x1,x3)
return(resultados)
} else{
# Actualizar los valores de los 3 puntos para que avancen
x1 = x2
x2 = x3
x3 = x2 + Dx
}
}
return("No existe minimo en (a,b) o un punto extremo es el minimo")
}
BE(fx,0,5,10)
fx = function(x){x^2 + 54/x}
BE(fx,0,5,10)
