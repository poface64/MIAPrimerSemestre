datosR
1:length(atributos)
i = 1
atributos[i]
datosR[,atributos[i]]
ncol(resultados)
ncol(resultados)-3
# Separar los esquemas
esquemas = resultados[,1:(ncol(resultados)-3)]
esquemas
resultados
# Aplicar esto para el atributo i-esimo
for(i in atributos){ # Moverse sobre todos los indices de atributos validos
#### PASO 1 ####
# Paso 1.1 Encuentra el valor máximo (dn) y el valor mínimo(d0) del atributo
d0 = min(datos[,i])
dn = max(datos[,i])
# Paso 1.2 Forma un conjunto de todos los valores distintos de F_i en orden
# ascendente, inicializa todos los posibles limites de los intervalos B con
# minimo, maximo y todos los puntos medios de todas las parejas adyacentes
unicos = sort(unique(datos[,i]))
B = c()
# Sacar las parejas
for(pi in 2:length(unicos)){
# Sacar las mitades
B[pi-1] = (unicos[pi]+unicos[pi-1])/2
}
### Paso 1.3 Define el esquema de discretización inicial como D: {[d0,dn]}
# y define el GlobalCaim = 0#
D = c(d0,dn) # Esquema de discretización base
GlobalCaim = 0 #Global Caim Base
#### PASO 2 ####
# Paso 2.1 Inicializa k = 1
k = 1
# Inicializo otras variables para hacer funcionar el while
maxCaim = 0
while((maxCaim > GlobalCaim) | (k<length(unique(datos[,ClaseS])))){
# 2.2 Tentativamente agrega un intervalo interno de B,
# el cual no se encuentre en D y calculale el correspondiente CAIM
# Indices de CAIM para elegir un esquema
ICAIM = c()
# Ciclo para probar con todas las posibles mitades como candidatos
# a ser parte del esquema
for(posi in 1:length(B)){
# Crea el esquema i-esimo
Di = sort(c(D,B[posi]))
# Discretiza con el esquema i-esimo
Inter = cut(datos[,i],
breaks = Di,
include.lowest = TRUE,
right = TRUE)
# Calcula el CAIM
ICAIM[posi] = CAIMp(Inter,datos[,ClaseS])
}
# 2.3 Una vez probadas todas las adiciones provisionales,
# aceptar la que tenga el valor más alto de de CAIM
# Extraigo el indice máximo y de caim y su posición
maxCaim = max(ICAIM) # Maximo Caim en la iteración i-esima
maxCaimPos = which.max(ICAIM) # Posición del maximo Caim
#2.4 Si (CAIM > GlobalCAIM O k<S) Actualiza D con la propuesta
#de intervalo aceptada en el paso 2.3 y configura GlobalCAIM = CAIM,
#si no termina
# Actualizar el esquema
D = sort(c(D,B[maxCaimPos])) # Actualización del esquema
#Quito el valor seleccionado de la bolsa de mitades B
B = B[-maxCaimPos]
# Actualiza el valor del global
GlobalCaim = maxCaim
k = k+1
}
# Reporta y guarda el resultado de la iteración
# Crear el resultado como un vector
vr = c(D,GlobalCaim,k,i)
resultados = append(resultados,list(vr))
}
resultados
# Primero aplica el detector para identificar a la variable clase
# de los atributos y quitar las variables NO numericas
detecta = detector(datos,VarClas)
# Separa la clase
ClaseS = detecta[length(detecta)]
# Separa los atributos considerados numericos
atributos = setdiff(detecta,ClaseS)
#### Inicializar el algoritmo para que itere sobre cada variable ####
# Genero los objetos con los resultados que van a ser guardados para la salida
resultados = list()
# Aplicar esto para el atributo i-esimo
for(i in atributos){ # Moverse sobre todos los indices de atributos validos
#### PASO 1 ####
# Paso 1.1 Encuentra el valor máximo (dn) y el valor mínimo(d0) del atributo
d0 = min(datos[,i])
dn = max(datos[,i])
# Paso 1.2 Forma un conjunto de todos los valores distintos de F_i en orden
# ascendente, inicializa todos los posibles limites de los intervalos B con
# minimo, maximo y todos los puntos medios de todas las parejas adyacentes
unicos = sort(unique(datos[,i]))
B = c()
# Sacar las parejas
for(pi in 2:length(unicos)){
# Sacar las mitades
B[pi-1] = (unicos[pi]+unicos[pi-1])/2
}
### Paso 1.3 Define el esquema de discretización inicial como D: {[d0,dn]}
# y define el GlobalCaim = 0#
D = c(d0,dn) # Esquema de discretización base
GlobalCaim = 0 #Global Caim Base
#### PASO 2 ####
# Paso 2.1 Inicializa k = 1
k = 1
# Inicializo otras variables para hacer funcionar el while
maxCaim = 0
while((maxCaim > GlobalCaim) | (k<length(unique(datos[,ClaseS])))){
# 2.2 Tentativamente agrega un intervalo interno de B,
# el cual no se encuentre en D y calculale el correspondiente CAIM
# Indices de CAIM para elegir un esquema
ICAIM = c()
# Ciclo para probar con todas las posibles mitades como candidatos
# a ser parte del esquema
for(posi in 1:length(B)){
# Crea el esquema i-esimo
Di = sort(c(D,B[posi]))
# Discretiza con el esquema i-esimo
Inter = cut(datos[,i],
breaks = Di,
include.lowest = TRUE,
right = TRUE)
# Calcula el CAIM
ICAIM[posi] = CAIMp(Inter,datos[,ClaseS])
}
# 2.3 Una vez probadas todas las adiciones provisionales,
# aceptar la que tenga el valor más alto de de CAIM
# Extraigo el indice máximo y de caim y su posición
maxCaim = max(ICAIM) # Maximo Caim en la iteración i-esima
maxCaimPos = which.max(ICAIM) # Posición del maximo Caim
#2.4 Si (CAIM > GlobalCAIM O k<S) Actualiza D con la propuesta
#de intervalo aceptada en el paso 2.3 y configura GlobalCAIM = CAIM,
#si no termina
# Actualizar el esquema
D = sort(c(D,B[maxCaimPos])) # Actualización del esquema
#Quito el valor seleccionado de la bolsa de mitades B
B = B[-maxCaimPos]
# Actualiza el valor del global
GlobalCaim = maxCaim
k = k+1
}
# Reporta y guarda el resultado de la iteración
# Crear el resultado como un vector
vr = c(D,GlobalCaim,k,i)
resultados = append(resultados,list(vr))
}
# Ya estando fuera de la función, puedo operar los resultados
# para reportar las salidas necesarias
### Colapsar en una matriz la lista de resultados
resultados = do.call(rbind, resultados)
# Separar los esquemas
esquemas = resultados[,1:(ncol(resultados)-3)]
# Caim por variable
Caim =cbind.data.frame(Variables = names(datos[,atributos]),
Caim = resultados[,(ncol(resultados)-2)])
# Usar los intervalos para discretizar por variable
datosR = datos
# Discretizar solo las variables que se les obtuvo el esquema
for(i in 1:length(atributos)){
# Aplicar la discretización para el atributo i-esimo dentro
# los permitidos
datosR[,atributos[i]] = cut(datosR[,atributos[i]],
breaks = Di,
include.lowest = TRUE,
right = TRUE)
}
resultados
# Usar los intervalos para discretizar por variable
datosR = datos
length(atributos)
datosR[,atributos[i]]
datosR
datosR[,atributos[i]]
# Separar los esquemas
esquemas = resultados[,1:(ncol(resultados)-3)]
esquemas
i = 1
cut(datosR[,atributos[i]],
breaks = esquemas[i,],
include.lowest = TRUE,
right = TRUE)
#Teniendo todo, se reporta en un solo objeto todo lo depurado
resultadoF = list(Discretizados = datosR,
CAIM = Caim,
Esquemas = esquemas)
resultadoF
i = 1
# Usar los intervalos para discretizar por variable
datosR = datos
datosR
datosR[,atributos[i]]
datosR[,atributos[i]]
esquemas[i,]
cut(datosR[,atributos[i]],
breaks = esquemas[i,],
include.lowest = TRUE,
right = TRUE)
# Usar los intervalos para discretizar por variable
datosR = datos
# Discretizar solo las variables que se les obtuvo el esquema
for(i in 1:length(atributos)){
# Aplicar la discretización para el atributo i-esimo dentro
# los permitidos
datosR[,atributos[i]] = cut(datosR[,atributos[i]],
breaks = esquemas[i,],
include.lowest = TRUE,
right = TRUE)
}
datosR
# Primero aplica el detector para identificar a la variable clase
# de los atributos y quitar las variables NO numericas
detecta = detector(datos,VarClas)
# Separa la clase
ClaseS = detecta[length(detecta)]
# Separa los atributos considerados numericos
atributos = setdiff(detecta,ClaseS)
#### Inicializar el algoritmo para que itere sobre cada variable ####
# Genero los objetos con los resultados que van a ser guardados para la salida
resultados = list()
# Aplicar esto para el atributo i-esimo
for(i in atributos){ # Moverse sobre todos los indices de atributos validos
#### PASO 1 ####
# Paso 1.1 Encuentra el valor máximo (dn) y el valor mínimo(d0) del atributo
d0 = min(datos[,i])
dn = max(datos[,i])
# Paso 1.2 Forma un conjunto de todos los valores distintos de F_i en orden
# ascendente, inicializa todos los posibles limites de los intervalos B con
# minimo, maximo y todos los puntos medios de todas las parejas adyacentes
unicos = sort(unique(datos[,i]))
B = c()
# Sacar las parejas
for(pi in 2:length(unicos)){
# Sacar las mitades
B[pi-1] = (unicos[pi]+unicos[pi-1])/2
}
### Paso 1.3 Define el esquema de discretización inicial como D: {[d0,dn]}
# y define el GlobalCaim = 0#
D = c(d0,dn) # Esquema de discretización base
GlobalCaim = 0 #Global Caim Base
#### PASO 2 ####
# Paso 2.1 Inicializa k = 1
k = 1
# Inicializo otras variables para hacer funcionar el while
maxCaim = 0
while((maxCaim > GlobalCaim) | (k<length(unique(datos[,ClaseS])))){
# 2.2 Tentativamente agrega un intervalo interno de B,
# el cual no se encuentre en D y calculale el correspondiente CAIM
# Indices de CAIM para elegir un esquema
ICAIM = c()
# Ciclo para probar con todas las posibles mitades como candidatos
# a ser parte del esquema
for(posi in 1:length(B)){
# Crea el esquema i-esimo
Di = sort(c(D,B[posi]))
# Discretiza con el esquema i-esimo
Inter = cut(datos[,i],
breaks = Di,
include.lowest = TRUE,
right = TRUE)
# Calcula el CAIM
ICAIM[posi] = CAIMp(Inter,datos[,ClaseS])
}
# 2.3 Una vez probadas todas las adiciones provisionales,
# aceptar la que tenga el valor más alto de de CAIM
# Extraigo el indice máximo y de caim y su posición
maxCaim = max(ICAIM) # Maximo Caim en la iteración i-esima
maxCaimPos = which.max(ICAIM) # Posición del maximo Caim
#2.4 Si (CAIM > GlobalCAIM O k<S) Actualiza D con la propuesta
#de intervalo aceptada en el paso 2.3 y configura GlobalCAIM = CAIM,
#si no termina
# Actualizar el esquema
D = sort(c(D,B[maxCaimPos])) # Actualización del esquema
#Quito el valor seleccionado de la bolsa de mitades B
B = B[-maxCaimPos]
# Actualiza el valor del global
GlobalCaim = maxCaim
k = k+1
}
# Reporta y guarda el resultado de la iteración
# Crear el resultado como un vector
vr = c(D,GlobalCaim,k,i)
resultados = append(resultados,list(vr))
}
# Ya estando fuera de la función, puedo operar los resultados
# para reportar las salidas necesarias
### Colapsar en una matriz la lista de resultados
resultados = do.call(rbind, resultados)
# Separar los esquemas
esquemas = resultados[,1:(ncol(resultados)-3)]
# Caim por variable
Caim =cbind.data.frame(Variables = names(datos[,atributos]),
Caim = resultados[,(ncol(resultados)-2)])
# Usar los intervalos para discretizar por variable
datosR = datos
# Discretizar solo las variables que se les obtuvo el esquema
for(i in 1:length(atributos)){
# Aplicar la discretización para el atributo i-esimo dentro
# los permitidos
datosR[,atributos[i]] = cut(datosR[,atributos[i]],
breaks = esquemas[i,],
include.lowest = TRUE,
right = TRUE)
}
#Teniendo todo, se reporta en un solo objeto todo lo depurado
resultadoF = list(Discretizados = datosR,
CAIM = Caim,
Esquemas = esquemas)
resultadoF
rm(list=ls())
source("C:/Users/Angel/Desktop/MIA PRIMER SEMESTRE/Machine Learning/TAREA 4. Algoritmo CAIM/funciones.R")
rm(list=ls())
### Tratar de ensamblar la función grande
library(palmerpenguins)
datos = as.data.frame(palmerpenguins::penguins)
datos = datos[is.na(datos$bill_length_mm)==F,]
VarClas = "species"
CAIM()
source("C:/Users/Angel/Desktop/MIA PRIMER SEMESTRE/Machine Learning/TAREA 4. Algoritmo CAIM/funciones.R")
CAIM()
CAIM(datos,VarClas)
CAIM = disc.Topdown(datos[,c(3,4,5,6,8)])
Catos = CAIM$Disc.data
CAIM$cutp
do.call(rbind.data.frame,CAIM$cutp)
do.call(rbind.data,CAIM$cutp)
do.call(rbind,CAIM$cutp)
CAIM(datos,VarClas)
source("C:/Users/Angel/Desktop/MIA PRIMER SEMESTRE/Machine Learning/TAREA 4. Algoritmo CAIM/funciones.R")
CAIM(datos,VarClas)
do.call(rbind,CAIM$cutp)
CAIM$cutp
CAIM$cutp
CAIM(datos,VarClas)
CAIM = disc.Topdown(datos[,c(3,4,5,6,8)])
Catos = CAIM$Disc.data
CAIM1 = disc.Topdown(datos[,c(3,4,5,6,8)])
CAIM1$cutp
source("C:/Users/Angel/Desktop/MIA PRIMER SEMESTRE/Machine Learning/TAREA 4. Algoritmo CAIM/funciones.R")
CAIM(datos,VarClas)
do.call(rbind,CAIM$cutp)
CAIM1 = disc.Topdown(datos[,c(3,4,5,6,8)])
CAIM1$cutp
CAIM(datos,VarClas)
do.call(rbind,CAIM1$cutp)
rm(list=ls())
### Tratar de ensamblar la función grande
library(palmerpenguins)
CAIM(datos,VarClas)
source("C:/Users/Angel/Desktop/MIA PRIMER SEMESTRE/Machine Learning/TAREA 4. Algoritmo CAIM/funciones.R")
datos = iris
#CAIM1 = disc.Topdown(datos[,c(3,4,5,6,8)])
CAIM1 = disc.Topdown(datos)
datos = iris
VarClas = "species"
CAIM(datos,VarClas)
datos = iris
VarClas = "Species"
CAIM(datos,VarClas)
do.call(rbind,CAIM1$cutp)
# Cargar el codigo fuente del CAIM
source("funciones.R")
# Cargar el codigo fuente del CAIM
source("funciones.R")
### Tratar de ensamblar la función grande
library(palmerpenguins)
#datos = as.data.frame(palmerpenguins::penguins)
#datos = datos[is.na(datos$bill_length_mm)==F,]
#VarClas = "species"
datos = iris
VarClas = "Species"
CAIM(datos,VarClas)
do.call(rbind,CAIM1$cutp)
#### Base de datos 1 IRIS ####
datos = iris
VarClas = "Species"
R1 = CAIM(datos,"Species")
R1$Discretizados
R1$CAIM
cbind.data.frame(R1$CAIM,R1$Esquemas)
Resumen1 = cbind.data.frame(R1$CAIM,R1$Esquemas)
# Cargar el codigo fuente del CAIM
library(flextable)
# Cargar el codigo fuente del CAIM
library(flextable)
source("funciones.R")
#### Base de datos 1 IRIS ####
datos = iris
VarClas = "Species"
R1 = CAIM(datos,"Species")
Resumen1 = cbind.data.frame(R1$CAIM,R1$Esquemas)
Resumen1
Resumen1
#### Base de datos 1 IRIS ####
datos = iris
VarClas = "Species"
R1 = CAIM(datos,"Species")
Resumen1 = cbind.data.frame(R1$CAIM,R1$Esquemas)
autofit(theme_box(flextable(Resumen1)))
#### Base de datos 1 IRIS ####
datos1 = iris
R1 = CAIM(datos1,"Species")
Resumen1 = cbind.data.frame(R1$CAIM,R1$Esquemas)
autofit(theme_box(flextable(Resumen1)))
datos2 = as.data.frame(penguins)
R2 = CAIM(datos2,"Species")
R2
datos2 = datos2[is.na(datos2$bill_length_mm)==F,]
R2 = CAIM(datos2,"Species")
R2 = CAIM(datos2,"Species")
Resumen2 = cbind.data.frame(R2$CAIM,R2$Esquemas)
autofit(theme_box(flextable(Resumen2)))
#### Base de datos 3 PIMA ####
install.packages("pdp")
#### Base de datos 3 PIMA ####
library(pdp)
datos3 = pima
datos3
library(DataCombine)
library(DataCombine)
datos3 = DropNA(pima)
dim(datos3)
source("C:/Users/Angel/Desktop/MIA PRIMER SEMESTRE/Machine Learning/TAREA 4. Algoritmo CAIM/CAIM MAIN.r")
str(pima)
#### Base de datos 3 PIMA ####
library(pdp)
library(DataCombine)
datos3 = pima
R3 = CAIM(datos3,"diabetes")
R3
#### Base de datos 3 PIMA ####
library(pdp)
library(DataCombine)
datos3 = pima
R3 = CAIM(datos3,"diabetes")
Resumen3 = cbind.data.frame(R3$CAIM,R3$Esquemas)
autofit(theme_box(flextable(Resumen3)))
Resumen1$Caim |> mean()
#### Base de datos 4 Heart Diases ####
install.packages("kmed")
#### Base de datos 4 Heart Diases ####
library(kmed)
datos4 = heart
head(datos4)
datos4$class
datos4$class =  ifelse(datos4$class==0,0,1)
datos4$class
R3 = CAIM(datos4,"class")
R4 = CAIM(datos4,"class")
#### Base de datos 4 Heart Diases ####
library(kmed)
datos4 = heart
datos4$class =  ifelse(datos4$class==0,0,1)
R4 = CAIM(datos4,"class")
Resumen4 = cbind.data.frame(R4$CAIM,R4$Esquemas)
autofit(theme_box(flextable(Resumen4)))
str(datos4)
#### Base de datos 5 Heart Diases ####
library(AER)
datos5 = SmokeBan
datos5 = read.csv("SmokeBan.csv")
datos5
install.packages("HDclassif")
#### Base de datos 5 Heart Diases ####
library(HDclassif)
datos5 = wine
datos5 = data(wine)
datos5
datos5 = wine
datos5
#### Base de datos 5 Heart Diases ####
library(HDclassif)
data(wine)
nombres <- c("Clase","Alcohol", "Malic acid", "Ash", "Alcalinity of ash",
nombres <- c("Clase","Alcohol", "Malic acid", "Ash", "Alcalinity of ash",
"Magnesium", "Total phenols", "Flavanoids", "Nonflavanoid phenols",
"Proanthocyanins", "Color intensity", "Hue",
"OD280/OD315 of diluted wines", "Proline")
#### Base de datos 5 Heart Diases ####
library(HDclassif)
data(wine)
#### Base de datos 5 Heart Diases ####
library(HDclassif)
data(wine)
nombres <- c("Clase","Alcohol", "Malic acid", "Ash", "Alcalinity of ash",
"Magnesium", "Total phenols", "Flavanoids", "Nonflavanoid phenols",
"Proanthocyanins", "Color intensity", "Hue",
"OD280/OD315 of diluted wines", "Proline")
datos5 = wine
names(datos5)
names(datos5) = nombres
names(datos5)
datos5$Clase = as.factor(datos5$Clase)
names(datos5)
datos5$Clase
R5 = CAIM(datos5,"Clase")
#### Base de datos 5 Heart Diases ####
library(HDclassif)
data(wine)
nombres <- c("Clase","Alcohol", "Malic acid", "Ash", "Alcalinity of ash",
"Magnesium", "Total phenols", "Flavanoids", "Nonflavanoid phenols",
"Proanthocyanins", "Color intensity", "Hue",
"OD280/OD315 of diluted wines", "Proline")
datos5 = wine
names(datos5) = nombres
datos5$Clase = as.factor(datos5$Clase)
R5 = CAIM(datos5,"Clase")
Resumen5 = cbind.data.frame(R5$CAIM,R5$Esquemas)
autofit(theme_box(flextable(Resumen5)))
